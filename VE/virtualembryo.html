<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Virtual Embryo!</title>
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow:scroll;
			}
			.info {
				position: absolute;
				background-color: black;
				opacity: 0.8;
				color: white;
				text-align: center;
				top: 0px;
				width: 100%;
			}
			.info a {
				color: #00ffff;
			}
		</style>
   <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.16/css/jquery.dataTables.min.css">

	</head>
	<body>
		<h1>Virtual Embryo!</h1>
		<div id="container"></div>
		<div id='territory'></div>
		<div><table id='dataTable'></table></div>

  <script src="js/three.min.js"></script>
  <script src="js/TrackBallControls.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script src="js/jquery-csv.js"></script>
  <script src="https://cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script>
  <script>
  	
	var container, stats;
	var camera, controls, scene, renderer;
	var spheres = [];
	var mouse ;
	var raycaster ;
	var intersects;

	init();
	animate();

	function init() {
		container = document.getElementById( "container" );
		
		//set camera
		camera = new THREE.PerspectiveCamera( 75, (window.innerWidth*.75)/(window.innerHeight*.75), 0.1, 1000 );
		camera.position.z = -50;
		
		//set scene
		scene = new THREE.Scene();
		scene.background = new THREE.Color( 0xffffff );	
		scene.add( new THREE.AmbientLight( 0x555555 ) );
		
		// create a point light   
    	var pointLight =
      		new THREE.PointLight(0xFFFFFF);
   		// set its position
   		pointLight.position.x = 100;
   		pointLight.position.y = 10;
	    pointLight.position.z = -80;
    	// add to the scene
		scene.add(pointLight);
    
    	//do this for three lights
   		var pointLight2 = 
    		new THREE.PointLight(0xFFFFFF);
    	pointLight2.position.x = -100;
  	 	pointLight2.position.y = 10;
    	pointLight2.position.z = -80;
    	scene.add(pointLight2);
    
    	var pointLight3 = 
    		new THREE.PointLight(0xFFFFFF);
    	pointLight3.position.x = 0;
    	pointLight3.position.y = 10;
    	pointLight3.position.z = 80;
   	 	scene.add(pointLight3);
   	 	
   	 	// Set up the spheres vars
    	var RADIUS = 5;
    	var SEGMENTS = 16;
    	var RINGS = 16;
    	
    	// loop through and draw 1000 spheres around the points of a big sphere
    	for(var i = 0; i < 1000; i++){
    
			// initial location and radius of sphere
			var x0 = 0
			var y0 = 0
			var z0 = 0
			var radius = 10
		
			// draw the sphere of spheres
			var u = Math.random();
	   		var v = Math.random();
   			var theta = 2 * Math.PI * u;
	   		var phi = Math.acos(2 * v - 1);
   			var x = x0 + (radius * Math.sin(phi) * Math.cos(theta));
   			var y = y0 + (radius * Math.sin(phi) * Math.sin(theta));
   			var z = z0 + (radius * Math.cos(phi));

   			var sphereMaterial;
   		
   			// logical getting the colors for the territories
   			if (y > -10 && y < -9 ){
   				sphereMaterial =	
   				new THREE.MeshLambertMaterial(
        		{
          			color: 0xff9900
       			});	    
			} else if (y > 1 && y < 5 ){
   				sphereMaterial =	
   				new THREE.MeshLambertMaterial(
  	    	  	{
          			color: 0xcc33ff
       			});
          	} else if (y >= 5 && y < 8 ) {
   			sphereMaterial =	
   			new THREE.MeshLambertMaterial(
        	{
          		color: 0x3399ff
       		});
       		} else if ( y >=8 ){
       		sphereMaterial =	
   			new THREE.MeshLambertMaterial(
        	{
          		color: 0x33cc33
       		});
          	} else {
          	sphereMaterial =	
   			new THREE.MeshLambertMaterial(
        	{
          		color: 0xb3b5b7
       		});
          	}
		
			// draw the individual sphere
			var sphere = new THREE.Mesh(
		    	new THREE.SphereGeometry(RADIUS,SEGMENTS,RINGS),
	    		sphereMaterial);
	    	
	    	   		
   			// set the positions
   			sphere.position.y = y
   			sphere.position.x = x
   			sphere.position.z = z

			// add the sphere to the scene.
	    	scene.add(sphere);
	    	// add to sphere array
	    	spheres.push( sphere );
	    	
		}
		
		renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth*.75, window.innerHeight*.75 );
		container.appendChild( renderer.domElement );
		
				//set controls
		controls = new THREE.TrackballControls( camera, container);
		controls.rotateSpeed = 1.0;
		controls.zoomSpeed = 1.2;
		controls.panSpeed = 0.8;
		controls.noZoom = false;
		controls.noPan = false;
		controls.staticMoving = true;
		controls.dynamicDampingFactor = 0.3;
		
		
		// set up ray to pick cells
		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();
		
		//add listeners
		container.addEventListener( 'mousedown', onDocumentMouseDown, false );
		container.addEventListener( 'touchstart', onDocumentTouchStart, false );
		window.addEventListener( 'resize', onWindowResize, false );
	}
	
	function onDocumentTouchStart( event ) {
		event.preventDefault();
		event.clientX = event.touches[0].clientX;
		event.clientY = event.touches[0].clientY;
		onDocumentMouseDown( event );
	}
	
	function onDocumentMouseDown( event ) {
		event.preventDefault();
		mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
		raycaster.setFromCamera( mouse, camera );
		var intersects = raycaster.intersectObjects( spheres );
		if ( intersects.length > 0 ) {
			var cellColor = intersects[ 0 ].object.material.color.getHex()
			intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
			if (cellColor === 0xb3b5b7){
				document.getElementById("territory").innerHTML = "YOU CLICKED AN ECTODERMAL CELL!";
			} else if (cellColor === 0xcc33ff){
				document.getElementById("territory").innerHTML = "YOU CLICKED AN EXTERNAL RING CELL"; 
			} else if (cellColor === 0x3399ff){
				document.getElementById("territory").innerHTML = "YOU CLICKED A CENTRAL RING CELL"; 
			} else if (cellColor === 0x33cc33){
				document.getElementById("territory").innerHTML = "YOU CLICKED A CENTRAL DOMAIN CELL"; 
			} else if (cellColor === 0xff9900){
				document.getElementById("territory").innerHTML = "YOU CLICKED AN APICAL DOMAIN CELL"; 
			}
		}
	} 
	
	function onWindowResize() {
		camera.aspect = window.innerWidth*.75 / window.innerHeight*.75;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth*.75, window.innerHeight*.75 );
	}
	
	function animate() {
		requestAnimationFrame( animate );
		render();
	};
	
	function render() {
		renderer.render(scene, camera);
		controls.update(); 
	}

var AllText;
function readTextFile(file)
{
    var rawFile = new XMLHttpRequest();
    rawFile.open("GET", file, false);
    rawFile.onreadystatechange = function ()
    {
        if(rawFile.readyState === 4)
        {
            if(rawFile.status === 200 || rawFile.status == 0)
            {
              allText = rawFile.responseText;
            }
        }
    }
    rawFile.send(null);
};

readTextFile('https://raw.githubusercontent.com/ScientistJake/ScientistJake.github.io/master/VE/tables/data.csv');

$(document).ready(function () {
var result = $.csv.toArrays(allText); 
var html = generateTable(result);

    // build HTML table data from an array (one or two dimensional)
    function generateTable(data) {
      var html = '';
      html += '<thead>\r\n';
      html += '</thead>\r\n';
	  html += '<tbody>\r\n';
        for(var row in data) {
          html += '<tr>\r\n';
          for(var item in data[row]) {
            html += '<td>' + data[row][item] + '</td>\r\n';
          }
          html += '</tr>\r\n';
        }
      html += '</tbody>';
      
      return html;
    }
document.getElementById("dataTable").innerHTML = html; 
//$('#dataTable').DataTable();
});
  </script>
  <script type="text/javascript">
    $(document).ready(function() {
        $('#dataTable').DataTable();
    });
</script>
</body>
</html>
